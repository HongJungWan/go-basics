package main

import (
	"fmt"
	"unsafe"
)

type Student struct {
	Age   int
	No    int
	Score float64
}

type User struct {
	A int8 // 1 바이트
	C int8 // 1 바이트
	E int8 // 1 바이트
	B int  // 8 바이트
	D int  // 8 바이트
}

func PrintStudent(s Student) {
	fmt.Printf("나이:%d, 번호:%d, 점수:%.2f\n", s.Age, s.No, s.Score)
}

func main() {
	var student = Student{15, 23, 88.2}
	student2 := student
	PrintStudent(student2)

	println("")

	user := User{1, 2, 3, 4, 5}
	fmt.Println(unsafe.Sizeof(user))
}

/*
- 구조체 안에 포함된 다른 구조체의 필드명을 생략하는 경우를 '포함된 필드'라고 부른다.
- 포함된 필드를 이용하면 점 .을 두 번 찍을 필요 없이 한 번만으로 바로 접근할 수 있어서 편리하다.

- 필드 안에 속한 필드명과 포함한 상위 구조체의 필드명이 서로 겹치는 경우는
- 상위 구조체를 통해 명시적으로 접근한다.

- 구조체 변수가 선언되면 컴퓨터는 구조체 필드를 모두 담을 수 있는 메모리 공간을 할당한다.

- 구조체 변숫값을 다른 구조체에 대입하면 모든 필드값이 복사된다.

- 📌 필드 배치 순서에 따른 구조체 크기 변화
-- 메모리 정렬(Memory Alignment) 개념을 알아야한다.
-- 메모리 정렬이란 컴퓨터가 데이터에 효과적으로 접근하고자 메모리를 일정 크기 간격으로 정렬하는 것을 말한다.

-- 레지스터는 실제 연산에 사용되는 데이터가 저장되는 곳이다.
-- 레지스터 크기가 4바이트인 컴퓨터를 32비트 컴퓨터라 부르고, 레지스터 크기가 8바이트인 컴퓨터를 64비트 컴퓨터라고 부른다.
-- 레지스터 크기가 8바이트라는 애기는 한 번 연산에 8바이트 크기를 연산할 수 있다는 말이다.
-- 따라서 데이터가 레지스터 크기와 똑같은 크기로 정렬되어 있으면 더욱 효율적으로 데이터를 읽어올 수 있다.
-- ex: 64비트 컴퓨터는 메모리가 8바이트 단위로 정렬되어 있는게 효율적이다.

- 📌 메모리 패딩을 고려한 필드 배치 방법
-- 메모리 정렬을 위해서 필드 사이에 공간을 띄우는 것을 메모리 패딩(Memory Padding)이라고 한다.
-- 8바이트보다 작은 필드는 8바이트 크기(단위)를 고려해서 몰아서 배치하자 ❗
-- 보통 패딩으로 인한 메모리 낭비는 크게 걱정하지 않아도 되지만, 임베디드 하드웨어 같은 경우라면 메모리 공간이 작기 때문에 패딩을 고려하는게 좋다.
*/
