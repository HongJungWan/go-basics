package main

// TODO: 해시로 맵을 만들자
const M = 10

func hash(d int) int {
	return d % M
}

func main() {
	/*
		해시 함수로 맵을 만들어보자.
		해시 함수는 결괏값이 항상 일정한 범위(개수)를 가진다. 같은 입력에서는 같은 결과를 보장하고, 일정 범위에서 반복된다.
		이런 특징을 고려하면 범위와 같은 요소 개수를 갖는 배열이 적합하다.
	*/
	m := [M]int{}

	m[hash(23)] = 10
	m[hash(33)] = 50
	// 기존 m[hash(23)] 값이 50으로 덮어쓰여진다, 해시 충돌 발생 -> 해결하기 위해서는 인덱스 위치마다 값이 아니라 리스트를 저장한다.
	// 값을 읽을 때 해당 인덱스에 링크된 모든 리스트를 조사해 매칭되는 키의 값을 반환하면 해시 충돌 문제에서 벗어나게 된다.

	// 해시 함수는 요소 개수와 상관없이 고정된 시간을 갖는 함수이기 때문에 해시 함수를 사용하는 맵이 읽기, 쓰기에서 O(1)의 시간값을 갖게 된다.
	// 또 키가 크다고 해시 함수 결괏값이 커지는게 아니기 때문에 맵은 키와 무관하고 입력 순서와도 무관한 순서로 순회하게 된다.
}

/*
📌 맵(map)은 키와 값 형태로 데이터를 저장하는 자료구조다.
- 언어에 따라서 딕셔너리, 해시테이블, 해시맵 등으로 부른다.
- Go 언어에서는 맵이라고 부른다. 맵은 리스트나 링과 달리 container 패키지가 아닌 Go 기본 내장 타입이다.
- 예를 들어 맵은 사전과 같다. 사전에 찾고 싶은 단어를 입력하면 단어의 뜻을 알려준다.

- 맵은 내부에서 요소를 보관할 때 입력한 순서와도 키 값과도 상관 없이 데이터를 보관한다.


📌 맵(map)은 반환값을 하나 혹은 둘로 받을 수 있다.
- 반환값을 하나만 받으면 값을 반환하고, 둘로 받으면 값뿐 아니라 요소가 존재하는지 알려주는 불리언도 반환한다.

```
m := make(map[int]int
m[3] = 3
v, ok := m[3]
```


📌 맵, 배열, 리스트 속도 비교

		배열, 슬라이스		리스트				맵
추가 	O(N)				O(1)				O(1)
삭제 	O(N)				O(1)				O(1)
읽기 	O(1) - 인덱스로 접근	O(N) - 인덱스로 접근	O(1) - 키로 접근

- 맵은 키와 값의 쌍으로만 동작하기 때문에 인덱스를 사용해서 접근할 수 없고 입력한 순서가 보장되지 않는다.
- 배열과 리스트에 비해 상대적으로 메모리를 많이 차지한다.


📌 맵은 왜 추가, 삭제, 읽기 연산에서 빠를까?
- 맵을 이해하려면 먼저 해시 함수(hash function)의 동작을 이해해야 한다.
- 맵(map)을 다른 말로 해시맵 또는 해시 테이블이라고 부를 만큼 맵과 해시는 뗄레야 뗄 수 없다.

-- 📌 해시 함수
---- 해시(hash)란 잘게 부순다는 뜻이다. 다음과 같은 3가지 특징을 만족해야 해시 함수라 부를 수 있다.
---- 1. 같은 입력이 들어오면 같은 결과가 나온다.
---- 2. 다른 입력이 들어오면 되도록 다른 결과가 나온다.
---- 3. 입력값의 범위는 무한대이고, 결과는 특정 범위를 갖는다.

---- 나머지 연산이 해시 함수로 자주 사용되는 이유는 계산이 간단해 매우 빠르고, 결괏값의 범위와 같격을 조절하기 쉽기 때문이다.
*/
